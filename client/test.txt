import paho.mqtt.client as mqtt
import psycopg2
import json
import numpy as np
import time
import os
from keras_facenet import FaceNet
import cv2
from PIL import Image
import io

# ğŸ“¡ Configuration MQTT
MQTT_BROKER = "192.168.8.5"
MQTT_PORT = 1883
MQTT_IMAGE_TOPIC = "station04/sensor/image"
MQTT_SENSOR_TOPICS = [
    "station04/sensor/DHT",
    "station04/sensor/PIR",
    "station04/sensor/Sound",
    "station04/sensor/AirQuality"
]
IMAGE_DIR = "C:/Users/loicm/Documents/mqtt/sae_vcod/dashboard/assets/img"

# ğŸ’¾ Connexion PostgreSQL
DB_NAME = "station_captation"
DB_USER = "postgres"
DB_PASSWORD = "Youtubel0wwik55110**"
DB_HOST = "localhost"

# ğŸš€ Initialisation du modÃ¨le FaceNet
embedder = FaceNet()

# ğŸ”„ Buffer pour stocker lâ€™image avant reconstitution
image_chunks = []
receiving_image = False

def connect_db():
    """Connexion Ã  PostgreSQL"""
    return psycopg2.connect(dbname=DB_NAME, user=DB_USER, password=DB_PASSWORD, host=DB_HOST)

# ğŸ“¥ Sauvegarde des DonnÃ©es des Capteurs
def save_sensor_data(topic, payload):
    conn = connect_db()
    cursor = conn.cursor()

    try:
        data = json.loads(payload)
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")

        if topic == "station04/sensor/DHT":
            cursor.execute("""
                INSERT INTO sensor_DHT (timestamp, temperature, humidity)
                VALUES (%s, %s, %s);
            """, (timestamp, data["temperature"], data["humidity"]))

        elif topic == "station04/sensor/PIR":
            cursor.execute("""
                INSERT INTO sensor_PIR (timestamp, motion_detected)
                VALUES (%s, %s);
            """, (timestamp, bool(data["move"])))

        elif topic == "station04/sensor/Sound":
            cursor.execute("""
                INSERT INTO sensor_Sound (timestamp, sound_level)
                VALUES (%s, %s);
            """, (timestamp, data["Sound"]))

        elif topic == "station04/sensor/AirQuality":
            cursor.execute("""
                INSERT INTO sensor_AirQuality (timestamp, TVoC, co2)
                VALUES (%s, %s, %s);
            """, (timestamp, data["TVoC"], data["co2"]))

        conn.commit()
        print(f"âœ… DonnÃ©es enregistrÃ©es pour {topic}")

    except Exception as e:
        print(f"âŒ Erreur lors de l'enregistrement des capteurs ({topic}) : {e}")

    finally:
        cursor.close()
        conn.close()

# ğŸ“¸ Sauvegarde des images en base
def save_image_to_db(image_path):
    conn = connect_db()
    cursor = conn.cursor()

    try:
        cursor.execute("INSERT INTO images (image_path) VALUES (%s) RETURNING id;", (image_path,))
        image_id = cursor.fetchone()[0]
        conn.commit()
        print(f"ğŸ“¸ Image enregistrÃ©e en base avec ID {image_id}")
        return image_id

    except Exception as e:
        print(f"âŒ Erreur lors de l'enregistrement de l'image : {e}")
        return None

    finally:
        cursor.close()
        conn.close()

# ğŸ“¸ Traitement de lâ€™image et dÃ©tection des visages
def process_image(image_data):
    timestamp = time.strftime("%Y-%m-%d_%H-%M-%S")
    image_path = f"{IMAGE_DIR}/image_{timestamp}.jpg"

    print(f"ğŸ“¥ Image complÃ¨te reÃ§ue - Taille : {len(image_data)} octets")

    # ğŸ“Œ VÃ©rifier si l'image commence par un en-tÃªte JPEG ou PNG
    if not (image_data[:2] == b'\xff\xd8' or image_data[:8] == b'\x89PNG\r\n\x1a\n'):
        print("ğŸš¨ Erreur : L'image reÃ§ue n'a pas un format valide (JPEG/PNG)")
        with open("debug_image.bin", "wb") as f:
            f.write(image_data)  # ğŸ“Œ Sauvegarde en binaire pour analyse
        return None, None

    try:
        image = Image.open(io.BytesIO(image_data))
        image = image.convert("RGB")
        image.save(image_path)

        print(f"âœ… Image sauvegardÃ©e : {image_path}")

        return image_path, None

    except Exception as e:
        print(f"âŒ Erreur lors du traitement de l'image : {e}")
        return None, None

# ğŸ“¡ RÃ©ception des messages MQTT (Images)
def on_message_image(client, userdata, msg):
    global image_chunks, receiving_image

    print(f"ğŸ“¥ Message reÃ§u sur {msg.topic} - Taille : {len(msg.payload)} octets")

    if msg.topic == MQTT_IMAGE_TOPIC:
        if msg.payload == b"END":
            print(f"ğŸ› ï¸ Reconstruction de l'image ({len(image_chunks)} chunks reÃ§us)...")

            # ğŸ“Œ VÃ©rifier les premiers octets aprÃ¨s reconstruction
            full_image_data = b"".join(image_chunks)
            print(f"ğŸ› ï¸ Taille totale reconstruite : {len(full_image_data)} octets")
            print(f"ğŸ” Premiers octets de l'image : {full_image_data[:20]}")

            # ğŸ“Œ Sauvegarder pour analyse
            with open("debug_image_reconstructed.jpg", "wb") as f:
                f.write(full_image_data)

            image_chunks = []
            receiving_image = False

            if len(full_image_data) > 0:
                process_image(full_image_data)
            else:
                print("âŒ Erreur : Image reÃ§ue vide aprÃ¨s reconstruction !")

        else:
            image_chunks.append(msg.payload)
            receiving_image = True
            print(f"ğŸ”„ Chunk ajoutÃ© ({len(msg.payload)} octets) - Total chunks : {len(image_chunks)}")

# ğŸ“¡ RÃ©ception des messages MQTT (Capteurs)
def on_message_sensor(client, userdata, msg):
    if msg.topic.startswith("station04/sensor/"):
        save_sensor_data(msg.topic, msg.payload)

# ğŸ“¡ Connexion MQTT pour les images
client_image = mqtt.Client()
client_image.connect(MQTT_BROKER, MQTT_PORT)
client_image.subscribe(MQTT_IMAGE_TOPIC)
client_image.on_message = on_message_image

# ğŸ“¡ Connexion MQTT pour les capteurs
client_sensors = mqtt.Client()
client_sensors.connect(MQTT_BROKER, MQTT_PORT)
for topic in MQTT_SENSOR_TOPICS:
    client_sensors.subscribe(topic)
client_sensors.on_message = on_message_sensor

# ğŸš€ Lancer les deux clients MQTT
print("ğŸ“¡ En attente des messages MQTT...")
client_image.loop_start()
client_sensors.loop_forever()
